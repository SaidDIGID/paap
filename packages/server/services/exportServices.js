import { Octokit } from "@octokit/rest";
import fetch from "node-fetch";

function b64(str) {
  return Buffer.from(str, "utf8").toString("base64");
}

export async function exportToGitHub({ token, owner, repo, branch, baseBranch, filePath, content, message, createPR }) {
  const octokit = new Octokit({ auth: token });

  // 1) Get base branch SHA
  const baseRef = await octokit.git.getRef({ owner, repo, ref: `heads/${baseBranch}` });
  const baseSha = baseRef.data.object.sha;

  // 2) Create branch
  await octokit.git.createRef({ owner, repo, ref: `refs/heads/${branch}`, sha: baseSha });

  // 3) Upsert file (need sha if exists)
  let existingSha = undefined;
  try {
    const existing = await octokit.repos.getContent({ owner, repo, path: filePath, ref: branch });
    if (existing?.data?.sha) existingSha = existing.data.sha;
  } catch { /* file doesn't exist */ }

  await octokit.repos.createOrUpdateFileContents({
    owner,
    repo,
    path: filePath,
    message,
    content: b64(content),
    branch,
    ...(existingSha ? { sha: existingSha } : {}),
  });

  // 4) Create PR
  if (createPR) {
    const pr = await octokit.pulls.create({
      owner,
      repo,
      title: "Add generated CI pipeline",
      head: branch,
      base: baseBranch,
      body: "Generated by Pipeline-as-a-Product platform.",
    });
    return { prUrl: pr.data.html_url };
  }

  return { branch };
}

export async function exportToGitLab({ token, baseUrl, projectId, branch, baseBranch, filePath, content, message, createMR }) {
  const api = `${baseUrl.replace(/\/$/, "")}/api/v4`;

  // 1) Create branch
  await fetch(`${api}/projects/${encodeURIComponent(projectId)}/repository/branches?branch=${encodeURIComponent(branch)}&ref=${encodeURIComponent(baseBranch)}`, {
    method: "POST",
    headers: { "PRIVATE-TOKEN": token }
  });

  // 2) Upsert file using Repository Files API
  // Check if file exists on that branch
  const getFileUrl = `${api}/projects/${encodeURIComponent(projectId)}/repository/files/${encodeURIComponent(filePath)}?ref=${encodeURIComponent(branch)}`;
  const exists = await fetch(getFileUrl, { headers: { "PRIVATE-TOKEN": token } });

  const method = exists.ok ? "PUT" : "POST";
  const url = `${api}/projects/${encodeURIComponent(projectId)}/repository/files/${encodeURIComponent(filePath)}`;

  const body = {
    branch,
    content,
    commit_message: message,
  };

  const upsert = await fetch(url, {
    method,
    headers: { "PRIVATE-TOKEN": token, "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });

  if (!upsert.ok) {
    const txt = await upsert.text();
    throw new Error(`GitLab upsert file failed: ${upsert.status} ${txt}`);
  }

  // 3) Create MR
  if (createMR) {
    const mr = await fetch(`${api}/projects/${encodeURIComponent(projectId)}/merge_requests`, {
      method: "POST",
      headers: { "PRIVATE-TOKEN": token, "Content-Type": "application/json" },
      body: JSON.stringify({
        source_branch: branch,
        target_branch: baseBranch,
        title: "Add generated CI pipeline",
        description: "Generated by Pipeline-as-a-Product platform."
      }),
    });

    if (!mr.ok) {
      const txt = await mr.text();
      throw new Error(`GitLab MR failed: ${mr.status} ${txt}`);
    }
    const data = await mr.json();
    return { mrUrl: data.web_url };
  }

  return { branch };
}
